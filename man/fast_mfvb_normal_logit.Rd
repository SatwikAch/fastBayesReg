% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{fast_mfvb_normal_logit}
\alias{fast_mfvb_normal_logit}
\title{Fast mean field variational Bayesian logistic regression with normal priors}
\usage{
fast_mfvb_normal_logit(
  y,
  X,
  max_iter = 5000L,
  tol = 1e-05,
  A = 10,
  in_E_inv_tau_sq = 1,
  in_E_omega = NULL,
  in_E_beta = NULL
)
}
\arguments{
\item{y}{vector of n binrary outcome variables taking values 0 or 1}

\item{X}{n x p matrix of candidate predictors}

\item{max_iter}{maximum number of iterations}

\item{tol}{the tolerance for the parameter changes}

\item{A}{scale parameter in the half Cauchy prior for regression coefficients}

\item{in_E_inv_tau_sq}{numeric scalar for the initial value for inverse of tau squared}

\item{in_E_omega}{numeric vector of length n for the initial values for all omega's}

\item{in_E_beta}{numeric vector of length p for the initial values for all beta's}
}
\value{
a list object consisting of three components
\describe{
\item{post_mean}{a list object of four components for posterior mean statistics}
\describe{
\item{betacoef}{a vector of posterior mean of p regression coeficients}
\item{inv_tau_sq}{posterior mean of inverse tau square}
\item{omega}{a vector of posterior mean of omega}
}
\item{trace}{a list object of two components for the trace of parameter updates}
\describe{
\item{inv_tau_sq}{a vector of trace for inverse of tau_sq}
\item{sum_beta_sq}{a vector of trace for inverse of summation of beta_sq}
}
\item{elapsed}{running time}
}
}
\description{
Fast mean field variational Bayesian logistic regression with normal priors
}
\examples{
set.seed(2022)
dat1 <- sim_logit_reg(n=2000,p=20,X_cor=0.5,X_var=1,q=10,beta_size=5)
split <- train_test_splits(nrow(dat1$X))
dat1$train_idx <- split$train_idx
dat1$test_idx <- split$test_idx
res1 <- with(dat1,fast_mfvb_normal_logit(y[train_idx],X[train_idx,]))
res1_mcmc <- with(dat1,fast_normal_logit(y[train_idx],X[train_idx,]))
res1_glmnet <- with(dat1,wrap_glmnet(y[train_idx],X[train_idx,],alpha=0.5,family=binomial()))
dat2 <- sim_logit_reg(n=200,p=400,X_cor=0.5,X_var=1,q=10,beta_size=5)
split <- train_test_splits(nrow(dat2$X))
dat2$train_idx <- split$train_idx
dat2$test_idx <- split$test_idx
res2 <- with(dat2,fast_mfvb_normal_logit(y[train_idx],X[train_idx,]))
res2_mcmc <- with(dat2,fast_normal_logit(y[train_idx],X[train_idx,]))
res2_glmnet <- with(dat1,wrap_glmnet(y[train_idx],X[train_idx,],alpha=0.5,family=binomial()))
tab1 <- data.frame(rbind(comp_sparse_SSE(dat1$betacoef,res1$post_mean$betacoef),
comp_sparse_SSE(dat1$betacoef,res1_glmnet$betacoef),
comp_sparse_SSE(dat1$betacoef,res1_mcmc$post_mean$betacoef)),
time=c(res1$elapsed,res1_glmnet$elapsed,
res1_mcmc$elapsed))
tab2 <- data.frame(rbind(comp_sparse_SSE(dat2$betacoef,res2$post_mean$betacoef),
comp_sparse_SSE(dat2$betacoef,res2_glmnet$betacoef),
comp_sparse_SSE(dat2$betacoef,res2_mcmc$post_mean$betacoef)),
time=c(res2$elapsed,res2_glmnet$elapsed,
res2_mcmc$elapsed))
rownames(tab1)<-c("n = 2000, p = 20 MFVB","n = 2000, p = 20 glmnet",
"n = 2000, p = 20 MCMC")
rownames(tab2)<-c("n = 200, p = 400 MFVB","n = 200, p = 400 glmnet",
"n = 200, p = 400 MCMC")
mfvb_logit_tab <- rbind(tab1,tab2)
print(mfvb_logit_tab)
}
\author{
Jian Kang <jiankang@umich.edu>
}
